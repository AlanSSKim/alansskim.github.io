---
layout: post
title: Chef / 3.Chef Server
category: Chef
tags: [DevOps, Chef]
comments: true
---

# Chef 활용

## 3. Chef Server

### 3.1 Chef Server 아키텍처

1장에서 chef-solo를 통해 로컬 서버를 관리하는 방법을 살펴봤다. 관리에 필요한 모든 내용들은 chef-repo 디렉토리밑에 작성하고 chef-solo가 그것을 불러다가 쓰는 형식이었다. 2장의 knife-solo 방식은 원격지에서 서버 node를 관리하는것처럼 보이지만 실제로는 recepe등의 설정 파일을 관리 대상 node에 ssh를 통해 전송하고 실제 설정은 해당 node의 chef-solo를 이용하는 방식이었다.

그러면 Chef Server와 이 둘간의 차이는 무엇일까? 가장 큰 차이점은 설정에 필요한 정보를 대상 node Repository에 두고 설정하지 않는다는 것이다. node들의 설정 정보는 Chef Server 상의 Repository에 저장되고 각 node들은 서버쪽에 저장된 자신의 환경 정보를 확인하여 자신의 상태를 변경하는 것이다. 이렇게 구성함으로써 중앙 집중적으로 node들을 관리할 수 있으며 확장성 있는 아키텍처를 가져갈 수 있다.

Chef 서버를 활용하는 방식에는 Chef Server, Chef Client, Chef Workstation의 3가지 주요 요소가 있다.

* Chef Server : cookbooks, cookbooks 적용된 Policy들, 각 node 의 메타 데이터들을 저장하고 있는 일종의 데이터 허브 역활. Chef Client가 요청하는 정보를 제공한다.
* Chef Client : 관리 대상이 되는 서버 node. Chef Client가 Agent 방식으로 Server쪽에 변경내용을 확인하여 적용한다.
* Chef Workstation : Chef 관리자용 시스템으로 cookbooks이나 Data Bag등을 만들어서 Server 쪽에 업로드 하거나 Node list에 node를 추가하거나 삭제하는 작업을 수행한다.

<img width="377" alt="2017-01-09 17 03 17" src="https://cloud.githubusercontent.com/assets/17682727/21760192/96112078-d68d-11e6-9206-cfe50d0ec119.PNG">

작동 순서

1. Workstation에서 Chef Server쪽으로 HTTPS를 통해 추가할 node의 정보를 전송한다.
2. Workstation에서 knife 툴을 사용하여 설정할 node에 Bootstrapping을 수행한다.
3. 해당 Node에는 Chef Client와 관련 디렉토리들이 인스톨 되게 되며 Chef Client가 Chef Server에 HTTPS를 통해 Json으로 정보를 가져온다.(Json over hatts, PULL방식) 이후 Chef Client는 정기적으로 Server쪽으로 변경 사항을 요청하고 자신의 상태를 업데이트 시킨다.

### 3.2 Chef Server Installation

Chef Server 설치는 Opscode Omnibus Packaging 을 사용하여 인스톨 한다. Chef Server를 구동하기 위해서는 FQDN을 할당하고 그 이름을 사용해야 한다. 그래서 /etc/hosts에 ip와 host의 FQDN을 미리 삽입해둔다.
* Chef server download (https://downloads.chef.io/chef-server/)

~~~~
# rpm -Uvh chef-server-core-12.11.1-1.el6.x86_64.rpm
# chef-server-ctl reconfigure
# netstat -nap | grep 443
tcp     0      0 0.0.0.0:443      0.0.0.0:*     LISTEN      2441/nginx
~~~~

![1](https://cloud.githubusercontent.com/assets/17682727/21748826/6f156f30-d5d2-11e6-9adb-f8c1e67077ed.jpg)

인스톨이 완료되면 웹브라우저를 통해 https://server 로 접근하면 위와 같이 Chef 화면에 접근할 수 있으나 사용자 설정이 아직 남아 있다. 아래와 같이 관리자를 생성한 후에 관리를 위한 모듈을 설치하자. 설치 과정에서 license 관련된 사항이 나오는데, 내용을 확인하고 yes를 입력하면 설치를 진행한다. 이후에 reconfigure를 통해 Chef 서버 환경을 재설정 해주면 모슨 설치가 완료된다.

~~~~
# chef-server-ctl user-create alan alan kim alan@test.com '123456' --filename alan-user-rsa
# chef-server-ctl org-create company 'your company' --association_user alan --filename company.pem
# chef-server-ctl install chef-manage
# chef-manage-ctl reconfigure
To use this software, you must agree to the terms of the software license agreement.
Press any key to continue.
Type 'yes' to accept the software license agreement, or anything else to cancel.
yes
....
# chef-manage-ctl reconfigure
~~~~

작업이 완료되면 web brower를 통해 Chef Server login 화면을 확인할 수 있다. 지정한 사용자와 패스워드로 로그인을 하자.

![2](https://cloud.githubusercontent.com/assets/17682727/21748836/c97f8866-d5d2-11e6-945b-50172a9242b6.jpg)

로그인을 하면 Chef의 관리 화면을 볼 수 있는데 아직 등록된 Client가 없는것을 확인 할 수 있다.

![3](https://cloud.githubusercontent.com/assets/17682727/21748842/07c446c0-d5d3-11e6-8cb9-0a0a6b5edaf0.jpg)


### 3.3 Workstation 과 Client node 인스톨

2장에서 Chef Solo를 통한 workstatoin과 node간의 통신은 ssh를 사용했다. 이번장에 Chef server에서는 ssh 통신이 아닌 SSL을 통해 Server와 workstation, node간 통신이 이루어지고, workstation과 node들은 Server와 SSL 통신을 위해 Server쪽의 인증서를 취득해야 한다.

먼저 Client node를 Provisioning (Bootstrapping)하기 위해서는 Chef 서버에 접근 허가(ssh permission)를 얻어내기 위해 SSL 인증서를 취득해야 한다. 이 과정에서 Chef Server쪽에서 SSL 인증서 생성하고 workstation과 node들에 배포해야 하는데, Chef 12에서는 이 과정을 간편하게 처리할 수 있는 Stater Kit이란 툴을 제공한다.

- Administration -> Organization name -> Starter Kit -> download Clik

<img width="484" alt="2017-01-08 19 08 26" src="https://cloud.githubusercontent.com/assets/17682727/21748983/fa57947a-d5d6-11e6-80dc-5803c6ed54cf.PNG">

User Key를 reset 한다는 메시지가 나오면 proceed 를 클릭하여 chef-starter.zip을 다운로드 한다.

<img width="483" alt="2017-01-08 19 10 55" src="https://cloud.githubusercontent.com/assets/17682727/21748984/0db0dd60-d5d7-11e6-9037-3996781f0942.PNG">

이제 workstation에 Chef를 인스톨 하고 다운 받은 chef-starter.zip 파일을 전송한 후 압축을 풀어 준다.

~~~~
[root@workstation ~]# url -L http://www.opscode.com/chef/install.sh | sudo bash
[root@workstation ~]# unzip chef-starter.zip
[root@workstation ~]# rm -f chef-starter.zip
[root@workstation ~]# cd chef-repo/.chef
[root@workstation chef-repo]# ls -al .chef/
total 16
drwxr-xr-x 2 root root 4096 Jan  8 19:11 .
drwxr-xr-x 5 root root 4096 Jan  8 19:23 ..
-rw-r--r-- 1 root root 1674 Jan  8 19:11 alan.pem
-rw-r--r-- 1 root root  409 Jan  8 19:11 knife.rb

[root@workstation chef-repo]# cat .chef/knife.rb
# See https://docs.getchef.com/config_rb_knife.html for more information on knife configuration options

current_dir = File.dirname(__FILE__)
log_level                :info
log_location             STDOUT
node_name                "alan"
client_key               "#{current_dir}/alan.pem"
chef_server_url          "https://server/organizations/company"
cookbook_path            ["#{current_dir}/../cookbooks"]=
~~~~

Zip파일을 풀면 .chef, cookbooks, roles 디렉토리가 나오는데 .chef 디렉토리 밑에는 인증서 파일과 함께 chef server 정보와 cookbook의 path등의 정보를 가지고 있는 knife.rb를 확인 할 수 있다.

이제 Chef Server에서 SSL 인증서를 취득해보자 다음과 같이 Knife ssl fetch 명령을 사용해서 인증서를 취득할 수 있다.

~~~~
[root@workstation .chef]# knife ssl fetch
WARNING: Certificates from server will be fetched and placed in your trusted_cert
directory (/root/chef-repo/.chef/trusted_certs).

Knife has no means to verify these are the correct certificates. You should
verify the authenticity of these certificates after downloading.

Adding certificate for server in /root/chef-repo/.chef/trusted_certs/server.crt
[root@workstation chef-repo]# tree .chef/
.chef/
├── alan.pem
├── knife.rb
└── trusted_certs
    └── server.crt
~~~~

./chef/trusted_certs 디렉토리 밑에 server.crt ssl 인증서를 가져온것을 확인 할 수 있다.
취득한 인증서를 통해 Chef Server와 SSL 통신이 제대로 되는 지 확인해보고, 현재 Chef 서버에 등록된 node들을 리스트를 확인해 보자.

~~~~
[root@workstation chef-repo]# knife ssl check
Connecting to host server:443
Successfully verified certificates from `server'
[root@workstation chef-repo]# knife client list
company-validator
node1
~~~~

이제 node1을 Chef Server에 등록해보자. 실제 서비스 서버에서는 root 계정이 아닌 user 계정을 사용할 것이므로 workstation에서 해당 node로 접근할 계정(여기서는 편의상 user로 생성)이 sudo 권한이 있는지 먼저 확인해보고 권한이 없으면 권한을 추가해주자.

~~~~
[root@node1 ~]# adduser user ; echo 'user:passwd' | chpasswd
[root@node1 ~]# groups user
user : user
[root@node1 ~]# usermod -g wheel user
[root@node1 ~]# groups user
user : wheel
[root@node1 ~]# echo -e '%wheel\tALL=(ALL)\tALL' >> /etc/sudoers
~~~~

이제 workstation에서 node1을 Chef 서버에 등록 하면 된다 등록할때는 knife 명령을 활용하며 knife bootstrap 'node ip' -N 'node FQDN' --ssh-user 'node에 sudo 권한을 갖고 있는 user' 명령을 통해 등록한다. knife 명령 수행시에는 관련 config 파일을 찾을 수 있도록 chef-repo 디렉토리상에서 수행한다.

~~~~
[root@workstation chef-repo]# knife bootstrap 192.168.1.146 -N node1 --ssh-user user --sudo
Creating new client for node1
Creating new node for node1
Connecting to 192.168.1.146
user@192.168.1.146's password:
192.168.1.146 knife sudo password:
Enter your password:
192.168.1.146
192.168.1.146 -----> Installing Chef Omnibus (-v 12)
192.168.1.146 downloading https://omnitruck-direct.chef.io/chef/install.sh
192.168.1.146   to file /tmp/install.sh.16815/install.sh
192.168.1.146 trying wget...
192.168.1.146 el 6 x86_64
192.168.1.146 Getting information for chef stable 12 for el...
192.168.1.146 downloading https://omnitruck-direct.chef.io/stable/chef/metadata?v=12&p=el&pv=6&m=x86_64
192.168.1.146   to file /tmp/install.sh.16820/metadata.txt
192.168.1.146 trying wget...
192.168.1.146 sha1      0e2eddb7da3bc99e8e079568376ebc1fc8ccca26
192.168.1.146 sha256    d2722da49d2039cfa5444f6fa3a820a3e3b9be8148a84524a5e814f0a69d9de3
192.168.1.146 url       https://packages.chef.io/files/stable/chef/12.17.44/el/6/chef-12.17.44-1.el6.x86_64.rpm
192.168.1.146 version   12.17.44
192.168.1.146 downloaded metadata file looks valid...
192.168.1.146 downloading https://packages.chef.io/files/stable/chef/12.17.44/el/6/chef-12.17.44-1.el6.x86_64.rpm
192.168.1.146   to file /tmp/install.sh.16820/chef-12.17.44-1.el6.x86_64.rpm
192.168.1.146 trying wget...
192.168.1.146 Comparing checksum with sha256sum...
192.168.1.146 Installing chef 12
192.168.1.146 installing with rpm...
192.168.1.146 warning: /tmp/install.sh.16820/chef-12.17.44-1.el6.x86_64.rpm: Header V4 DSA/SHA1 Signature, key ID 83ef826a: NOKEY
192.168.1.146 Preparing...                ########################################### [100%]
192.168.1.146    1:chef                   ########################################### [100%]
192.168.1.146 Thank you for installing Chef!
192.168.1.146 Starting the first Chef Client run...
192.168.1.146 Starting Chef Client, version 12.17.44
192.168.1.146 resolving cookbooks for run list: []
192.168.1.146 Synchronizing Cookbooks:
192.168.1.146 Installing Cookbook Gems:
192.168.1.146 Compiling Cookbooks...
192.168.1.146 [2017-01-08T20:11:30+09:00] WARN: Node node1 has an empty run list.
192.168.1.146 Converging 0 resources
192.168.1.146
192.168.1.146 Running handlers:
192.168.1.146 Running handlers complete
192.168.1.146 Chef Client finished, 0/0 resources updated in 02 seconds
~~~~

이렇게 해서 node 등록이 완료되었다. 이 node에서 Chef Server와 SSL 통신을 하기 위한 인증서를 제대로 취득했는지 아래와 같이 확인해보자. workstation이나 node에서 Chef Server와 SSL 통신에 문제가 있을때는 아래와 같이 인증서를 제대로 취득했는지 확인이 필요하다.

~~~~
[root@node1 ~]# ls /etc/chef/trusted_certs/
server.crt
~~~~~

자 이제 웹 브라우저를 열어서 Chef Server의 콘솔 화면을 통해 등록된 node를 확인해보자.

<img width="556" alt="2017-01-08 20 17 07" src="https://cloud.githubusercontent.com/assets/17682727/21749347/7d2ff3e8-d5e0-11e6-9c5f-5e4782980fc9.PNG">

attributes를 클릭하면 ohai 를 통해 가져온 자세한 서버 정보들을 확인할 수 있다.

<img width="554" alt="2017-01-08 20 18 04" src="https://cloud.githubusercontent.com/assets/17682727/21749358/9df63754-d5e0-11e6-9f87-18fb260c4748.PNG">
